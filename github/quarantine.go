// Package github provides utilities for manipulating GitHub branches and PRs.
package github

import (
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/google/go-github/v73/github"
	"github.com/rs/zerolog"

	"github.com/smartcontractkit/branch-out/golang"
)

// QuarantineTestRequest represents a request to quarantine a test
type QuarantineTestRequest struct {
	Owner            string // GitHub repository owner
	Repo             string // GitHub repository name
	FilePath         string // Path to the Go test file
	TestFunctionName string // Name of the test function to quarantine
	BranchName       string // Name of the branch to create (optional, will be generated if empty)
	CommitMessage    string // Commit message (optional, will be generated if empty)
	PRTitle          string // PR title (optional, will be generated if empty)
	PRBody           string // PR body (optional, will be generated if empty)
}

// QuarantineTestResponse represents the response from quarantining a test
type QuarantineTestResponse struct {
	BranchName string // Name of the created branch
	CommitSHA  string // SHA of the commit that quarantined the test
	PRURL      string // URL of the created pull request
}

// QuarantineTest quarantines a Go test by creating a branch, adding t.Skip(), and creating a PR
func (c *Client) QuarantineTest(
	ctx context.Context,
	l zerolog.Logger,
	req QuarantineTestRequest,
) (*QuarantineTestResponse, error) {
	// Validate request
	if err := validateQuarantineRequest(req); err != nil {
		return nil, fmt.Errorf("invalid request: %w", err)
	}

	// Generate defaults if not provided
	if req.BranchName == "" {
		req.BranchName = fmt.Sprintf("quarantine-%s", strings.ReplaceAll(req.TestFunctionName, "_", "-"))
	}
	if req.CommitMessage == "" {
		req.CommitMessage = fmt.Sprintf("Quarantine test %s in %s", req.TestFunctionName, req.FilePath)
	}
	if req.PRTitle == "" {
		req.PRTitle = fmt.Sprintf("Quarantine flaky test: %s", req.TestFunctionName)
	}
	if req.PRBody == "" {
		req.PRBody = fmt.Sprintf(
			"This PR quarantines the flaky test `%s` in `%s` by adding `t.Skip()` at the beginning of the test function.\n\nThis was automatically generated by branch-out.",
			req.TestFunctionName,
			req.FilePath,
		)
	}

	l = l.With().
		Str("owner", req.Owner).
		Str("repo", req.Repo).
		Str("file_path", req.FilePath).
		Str("test_function", req.TestFunctionName).
		Str("branch_name", req.BranchName).
		Logger()

	// Get the default branch
	repo, _, err := c.Rest.Repositories.Get(ctx, req.Owner, req.Repo)
	if err != nil {
		return nil, fmt.Errorf("failed to get repository: %w", err)
	}
	defaultBranch := repo.GetDefaultBranch()

	l.Debug().Str("default_branch", defaultBranch).Msg("Retrieved default branch")

	// Get the current file content
	fileContent, _, resp, err := c.Rest.Repositories.GetContents(
		ctx,
		req.Owner,
		req.Repo,
		req.FilePath,
		&github.RepositoryContentGetOptions{
			Ref: defaultBranch,
		},
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get file content: %w", err)
	}
	if resp.StatusCode != http.StatusOK {
		body, err := io.ReadAll(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("failed to read response body from GitHub API: %w", err)
		}
		return nil, fmt.Errorf("failed to get file content %s: %s", resp.Status, string(body))
	}

	if fileContent == nil {
		return nil, fmt.Errorf("file %s not found", req.FilePath)
	}

	// Decode the file content
	content, err := fileContent.GetContent()
	if err != nil {
		return nil, fmt.Errorf("failed to decode file content: %w", err)
	}

	l.Debug().Int("content_length", len(content)).Msg("Retrieved file content")

	// Quarantine the test
	modifiedContent, err := golang.QuarantineTest(content, req.TestFunctionName)
	if err != nil {
		return nil, fmt.Errorf("failed to quarantine test: %w", err)
	}

	// Check if content was actually modified
	if modifiedContent == content {
		l.Info().Msg("Test is already quarantined, skipping")
		return &QuarantineTestResponse{
			BranchName: req.BranchName,
			CommitSHA:  "",
			PRURL:      "",
		}, nil
	}

	// Create a new branch
	err = c.createBranch(ctx, l, req.Owner, req.Repo, req.BranchName, defaultBranch)
	if err != nil {
		return nil, fmt.Errorf("failed to create branch: %w", err)
	}

	// Update the file with quarantined test
	commitSHA, err := c.updateFile(
		ctx,
		l,
		req.Owner,
		req.Repo,
		req.FilePath,
		req.BranchName,
		modifiedContent,
		req.CommitMessage,
		fileContent.GetSHA(),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to update file: %w", err)
	}

	// Create pull request
	prURL, err := c.createPullRequest(
		ctx,
		l,
		req.Owner,
		req.Repo,
		req.BranchName,
		defaultBranch,
		req.PRTitle,
		req.PRBody,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create pull request: %w", err)
	}

	l.Info().
		Str("commit_sha", commitSHA).
		Str("pr_url", prURL).
		Msg("Successfully quarantined test")

	return &QuarantineTestResponse{
		BranchName: req.BranchName,
		CommitSHA:  commitSHA,
		PRURL:      prURL,
	}, nil
}

// validateQuarantineRequest validates the quarantine request
func validateQuarantineRequest(req QuarantineTestRequest) error {
	if req.Owner == "" {
		return fmt.Errorf("owner is required")
	}
	if req.Repo == "" {
		return fmt.Errorf("repo is required")
	}
	if req.FilePath == "" {
		return fmt.Errorf("file path is required")
	}
	if req.TestFunctionName == "" {
		return fmt.Errorf("test function name is required")
	}
	if !strings.HasPrefix(req.TestFunctionName, "Test") {
		return fmt.Errorf("test function name must start with 'Test'")
	}
	return nil
}

// createBranch creates a new branch from the default branch
func (c *Client) createBranch(ctx context.Context, l zerolog.Logger, owner, repo, branchName, baseBranch string) error {
	// Get the base branch reference
	baseRef, _, err := c.Rest.Git.GetRef(ctx, owner, repo, "refs/heads/"+baseBranch)
	if err != nil {
		return fmt.Errorf("failed to get base branch reference: %w", err)
	}

	// Create new branch reference
	newRef := &github.Reference{
		Ref: github.Ptr(fmt.Sprintf("refs/heads/%s", branchName)),
		Object: &github.GitObject{
			SHA: baseRef.Object.SHA,
		},
	}

	_, _, err = c.Rest.Git.CreateRef(ctx, owner, repo, newRef)
	if err != nil {
		// If branch already exists, that's okay
		if !strings.Contains(err.Error(), "already exists") {
			return fmt.Errorf("failed to create branch: %w", err)
		}
		l.Debug().Msg("Branch already exists, continuing")
	} else {
		l.Debug().Msg("Created new branch")
	}

	return nil
}

// updateFile updates a file in the repository
func (c *Client) updateFile(
	ctx context.Context,
	l zerolog.Logger,
	owner, repo, filePath, branchName, content, commitMessage, sha string,
) (string, error) {
	updateOptions := &github.RepositoryContentFileOptions{
		Message: github.Ptr(commitMessage),
		Content: []byte(content),
		SHA:     github.Ptr(sha),
		Branch:  github.Ptr(branchName),
	}

	contentResponse, _, err := c.Rest.Repositories.UpdateFile(ctx, owner, repo, filePath, updateOptions)
	if err != nil {
		return "", fmt.Errorf("failed to update file: %w", err)
	}

	l.Debug().Str("commit_sha", contentResponse.Commit.GetSHA()).Msg("Updated file")
	return contentResponse.GetSHA(), nil
}

// createPullRequest creates a pull request from the branch to the base branch
func (c *Client) createPullRequest(
	ctx context.Context,
	l zerolog.Logger,
	owner, repo, headBranch, baseBranch, title, body string,
) (string, error) {
	pr := &github.NewPullRequest{
		Title: github.Ptr(title),
		Head:  github.Ptr(headBranch),
		Base:  github.Ptr(baseBranch),
		Body:  github.Ptr(body),
	}

	createdPR, _, err := c.Rest.PullRequests.Create(ctx, owner, repo, pr)
	if err != nil {
		return "", fmt.Errorf("failed to create pull request: %w", err)
	}

	prURL := createdPR.GetHTMLURL()
	l.Debug().Str("pr_url", prURL).Msg("Created pull request")
	return prURL, nil
}

// ParseRepoURL parses a GitHub repository URL and returns owner and repo name
func ParseRepoURL(repoURL string) (owner, repo string, err error) {
	if repoURL == "" {
		return "", "", fmt.Errorf("repository URL is required")
	}

	// Parse the URL
	u, err := url.Parse(repoURL)
	if err != nil {
		return "", "", fmt.Errorf("invalid repository URL: %w", err)
	}

	// Extract owner and repo from path
	path := strings.Trim(u.Path, "/")
	parts := strings.Split(path, "/")

	if len(parts) < 2 {
		return "", "", fmt.Errorf("invalid repository URL format, expected: https://github.com/owner/repo")
	}

	owner = parts[0]
	repo = parts[1]

	// Remove .git suffix if present
	repo = strings.TrimSuffix(repo, ".git")

	return owner, repo, nil
}
